covered = set()

def reading_list(graph, query, user_model=DEFAULT_BEGINNER_MODEL):
    """Generate a reading list for the query using a concept graph, adjusted
    based on the user model (mapping topics to scores of expertise)."""

    global covered

    # Get (at most 4) topics containing the query, ordered by relevance.
    # Relevance will be based on (partial) word matches in the topic word
    # distribution.
    matches = graph.search(query)[:4]
    # Remove matches if they occur in the dependencies of another match.
    matches = remove_submatches(matches)

    for m in matches:
        # Generate a reading list for each match. For the demo interface,
        # just return the reading list for the most relevant topic, unless
        # we update the interface.
        covered = set()
        topic_reading_list(m, user_model)


def topic_reading_list(topic, user_model):
    """Print a reading list for the topic and its dependencies."""

    global covered

    # Have we previously covered this topic, e.g., it was a dependency of
    # an earlier topic?
    if topic in covered:
        return

    # If we've covered its dependencies -- or it doesn't have any -- just
    # print the best introduction to the topic.
    if all of topic.depends() in covered:
        if user_model[topic] == EXPERT:
            print topic.doc(type=ADVANCED)
        else:
            print topic.doc(type=INTRO)
    else:
        print topic.doc(type=OVERVIEW)
        map(lambda x: topic_reading_list(x, user_model),
            topic.depends())
        if user_model[topic] == BEGINNER:
            print topic.doc(type=TUTORIAL)
        else:
            print topic.doc(type=ADVANCED)
        # Print one or two more advanced documents for experts?


def remove_submatches(topics):
    """Return the sorted list of topics without any that would be included as
    a dependency for one of the other topics. When removing a topic, add its
    relevance score to the topic it's a dependency of."""
    # For each topic t in topics, find its dependencies to a fixed depth,
    # and remove each of these from the topic list...


class Topic:
    def doc(self, type=INTRO):
        """Return the best document of the specified type for this topic."""
        # Get a list of all documents with relevance to the topic > threshold
        # (0.5? Experiment.) Then sort by probability of being of the
        # requested type.

    def depends(self, recursive=False):
        # Return the topics that this topic depends upon -- by default
        # only one level, not recursive. This will need some threshold
        # for how strong a dependency needs to be, which can be adjusted
        # based on depth in the reading list.
